<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Career Coach Voice Agent</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        
        :root {
            --bg-warm: #f8fafc;
            --bg-card: #ffffff;
            --accent-primary: #7c3aed;
            --accent-secondary: #3b82f6;
            --accent-danger: #ef4444;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-subtle: #e2e8f0;
            --shadow-soft: 0 2px 16px rgba(30, 41, 59, 0.06);
            --shadow-hover: 0 4px 24px rgba(30, 41, 59, 0.1);
        }
        
        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            margin: 0;
            padding: 24px;
            background: var(--bg-warm);
            background-image:
                radial-gradient(ellipse at 0% 0%, rgba(124, 58, 237, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 100% 100%, rgba(59, 130, 246, 0.08) 0%, transparent 50%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .container {
            max-width: 520px;
            width: 100%;
        }
        
        .panel {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            padding: 36px;
            box-shadow: var(--shadow-soft);
        }
        
        .header {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 6px;
        }
        
        .logo {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 2px 8px rgba(124, 58, 237, 0.25);
        }
        
        h1 { 
            margin: 0;
            font-size: 26px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.5px;
        }
        
        .subtitle {
            color: var(--text-secondary);
            margin: 0 0 28px 0;
            font-size: 15px;
        }
        
        /* Provider Selection */
        .provider-section {
            margin-bottom: 24px;
        }
        
        .section-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .section-label::before {
            content: '';
            width: 3px;
            height: 12px;
            border-radius: 2px;
        }
        
        .section-label.stt::before {
            background: var(--accent-secondary);
        }

        .section-label.tts::before {
            background: var(--accent-primary);
        }
        
        .provider-select-wrapper {
            position: relative;
            width: 100%;
        }
        
        .provider-select {
            width: 100%;
            padding: 14px 40px 14px 16px;
            font-size: 14px;
            font-weight: 500;
            font-family: inherit;
            color: var(--text-primary);
            background: var(--bg-warm);
            border: 2px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            transition: all 0.2s ease;
        }
        
        .provider-select:hover {
            background: #f5f2ed;
        }
        
        .provider-select:focus {
            outline: none;
            background: #fff;
            border-color: var(--accent-secondary);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.12);
        }

        .provider-select.tts-select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(124, 58, 237, 0.15);
        }
        
        .provider-select option {
            padding: 12px;
            background: var(--bg-card);
            color: var(--text-primary);
        }
        
        .provider-select option:disabled {
            color: var(--text-muted);
        }
        
        .provider-select-wrapper::after {
            content: '';
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid var(--text-muted);
            pointer-events: none;
            transition: border-color 0.2s ease;
        }
        
        .provider-select-wrapper:has(.provider-select:focus)::after {
            border-top-color: var(--accent-secondary);
        }

        .provider-select-wrapper:has(.tts-select:focus)::after {
            border-top-color: var(--accent-primary);
        }
        
        /* Divider */
        .divider {
            height: 1px;
            background: var(--border-subtle);
            margin: 24px 0;
        }
        
        /* Buttons */
        .button-group {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 14px 22px;
            font-size: 15px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.2s ease;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        #startBtn {
            background: linear-gradient(135deg, var(--accent-primary), #6d28d9);
            color: #fff;
            border: none;
            box-shadow: 0 2px 12px rgba(124, 58, 237, 0.3);
        }

        #startBtn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(124, 58, 237, 0.35);
        }
        
        #startBtn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        #startBtn:disabled { 
            background: #d1d0ce;
            color: #a3a19e;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        #stopBtn {
            background: #fff;
            color: var(--accent-danger);
            border: 2px solid #fecaca;
        }

        #stopBtn:hover:not(:disabled) {
            background: #fef2f2;
            border-color: #fca5a5;
        }
        
        #stopBtn:disabled { 
            background: #fafafa;
            color: #c4c2c0;
            border-color: #e8e6e4;
            cursor: not-allowed;
        }
        
        /* Status */
        .status-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 18px;
            background: var(--bg-warm);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #c4c2c0;
            flex-shrink: 0;
        }
        
        .status-dot.connected {
            background: #22c55e;
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.15);
        }

        .status-dot.recording {
            background: var(--accent-danger);
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.15);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
        }
        
        .status-text {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .status-providers {
            margin-left: auto;
            display: flex;
            gap: 6px;
        }
        
        .provider-badge {
            font-size: 10px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 6px;
            background: #e8e4de;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .provider-badge.stt {
            background: rgba(59, 130, 246, 0.12);
            color: var(--accent-secondary);
        }

        .provider-badge.tts {
            background: rgba(124, 58, 237, 0.15);
            color: var(--accent-primary);
        }
        
        /* Activity Log */
        .log-header {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 10px;
        }
        
        .log {
            background: var(--bg-warm);
            border: 1px solid var(--border-subtle);
            padding: 14px;
            height: 180px;
            overflow-y: auto;
            border-radius: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .log div {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.04);
            line-height: 1.5;
        }
        
        .log div:last-child { 
            border-bottom: none; 
        }
        
        .log .timestamp {
            color: var(--text-muted);
            margin-right: 8px;
        }
        
        /* Loading state */
        .loading-providers {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 13px;
        }
        
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-subtle);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <div class="header">
                <div class="logo">ðŸŽ¯</div>
                <h1 id="pageTitle">Career Coach</h1>
            </div>
            <p class="subtitle" id="pageSubtitle">Talk with your AI career coach</p>
            
            <!-- Provider Selection -->
            <div class="provider-section" id="sttSection">
                <div class="section-label stt">Speech Recognition</div>
                <div class="provider-select-wrapper" id="sttProviders">
                    <select class="provider-select" id="sttSelect" disabled>
                        <option>Loading providers...</option>
                    </select>
                </div>
            </div>
            
            <div class="provider-section" id="ttsSection">
                <div class="section-label tts">Voice Synthesis</div>
                <div class="provider-select-wrapper" id="ttsProviders">
                    <select class="provider-select tts-select" id="ttsSelect" disabled>
                        <option>Loading providers...</option>
                    </select>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="button-group">
                <button id="startBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" x2="12" y1="19" y2="22"/>
                    </svg>
                    Start Call
                </button>
                <button id="stopBtn" disabled>End Call</button>
            </div>
            
            <div class="status-bar">
                <span class="status-dot" id="statusDot"></span>
                <span class="status-text" id="status">Ready to help with your career</span>
                <div class="status-providers" id="statusProviders"></div>
            </div>
            
            <div class="log-header">Activity</div>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('status');
        const statusDot = document.getElementById('statusDot');
        const statusProviders = document.getElementById('statusProviders');
        const logDiv = document.getElementById('log');
        const sttSelect = document.getElementById('sttSelect');
        const ttsSelect = document.getElementById('ttsSelect');
        const pageTitle = document.getElementById('pageTitle');
        const pageSubtitle = document.getElementById('pageSubtitle');

        let signalingWs, peerConnection, audioDataChannel;
        let audioContext, workletNode, mediaStream;
        let nextStartTime = 0;
        let scheduledAudioSources = [];

        // Get user name from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const userName = urlParams.get('name');

        // Update page title with user name
        if (userName) {
            pageTitle.textContent = `Hi, ${userName}!`;
            pageSubtitle.textContent = 'Your AI career coach is ready';
            document.title = `Career Coach - ${userName}`;
        }

        // Selected providers
        let selectedSTT = 'assemblyai';
        let selectedTTS = 'elevenlabs';
        
        // Provider icon mapping
        const providerIcons = {
            assemblyai: 'A',
            openai: 'O',
            elevenlabs: 'E',
            hume: 'H'
        };

        function log(msg) {
            const p = document.createElement('div');
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            p.innerHTML = `<span class="timestamp">${time}</span>${msg}`;
            logDiv.appendChild(p);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function setStatus(text, state = 'idle') {
            statusDiv.innerText = text;
            statusDot.className = 'status-dot';
            if (state === 'connected') statusDot.classList.add('connected');
            if (state === 'recording') statusDot.classList.add('recording');
        }
        
        function updateProviderBadges() {
            const sttLabel = sttSelect.options[sttSelect.selectedIndex]?.text || selectedSTT;
            const ttsLabel = ttsSelect.options[ttsSelect.selectedIndex]?.text || selectedTTS;
            
            statusProviders.innerHTML = `
                <span class="provider-badge stt">${sttLabel}</span>
                <span class="provider-badge tts">${ttsLabel}</span>
            `;
        }
        
        // Load available providers from server
        async function loadProviders() {
            try {
                const response = await fetch('/api/providers');
                const providers = await response.json();
                
                renderProviders('stt', providers.stt, sttSelect);
                renderProviders('tts', providers.tts, ttsSelect);
                
                // Set defaults based on availability
                const availableSTT = providers.stt.find(p => p.available);
                const availableTTS = providers.tts.find(p => p.available);
                
                if (availableSTT) {
                    selectedSTT = availableSTT.id;
                    sttSelect.value = availableSTT.id;
                }
                if (availableTTS) {
                    selectedTTS = availableTTS.id;
                    ttsSelect.value = availableTTS.id;
                }
                
                updateProviderBadges();
            } catch (error) {
                console.error('Failed to load providers:', error);
                sttSelect.innerHTML = '<option disabled>Failed to load</option>';
                ttsSelect.innerHTML = '<option disabled>Failed to load</option>';
            }
        }
        
        function renderProviders(type, providers, selectElement) {
            selectElement.innerHTML = providers.map(provider => {
                const isSelected = (type === 'stt' && provider.id === selectedSTT) || 
                                   (type === 'tts' && provider.id === selectedTTS);
                const unavailableText = !provider.available ? ' (API key missing)' : '';
                
                return `<option value="${provider.id}" 
                                ${isSelected ? 'selected' : ''} 
                                ${!provider.available ? 'disabled' : ''}>${provider.name}${unavailableText}</option>`;
            }).join('');
            
            selectElement.disabled = false;
            
            // Add event listener
            selectElement.addEventListener('change', (e) => {
                if (type === 'stt') {
                    selectedSTT = e.target.value;
                } else {
                    selectedTTS = e.target.value;
                }
                updateProviderBadges();
                log(`Selected ${type.toUpperCase()}: ${e.target.value}`);
            });
        }
        
        // Initialize
        loadProviders();

        const workletCode = `
            class PCMProcessor extends AudioWorkletProcessor {
                constructor() {
                    super();
                    this.buffer = [];
                    this.resampleRatio = sampleRate / 16000;
                    this.resampleIndex = 0;
                }
                process(inputs) {
                    const input = inputs[0];
                    if (!input || !input[0]) return true;
                    const channelData = input[0];
                    for (let i = 0; i < channelData.length; i++) {
                        this.resampleIndex += 1;
                        if (this.resampleIndex >= this.resampleRatio) {
                            this.resampleIndex -= this.resampleRatio;
                            let sample = Math.max(-1, Math.min(1, channelData[i]));
                            const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                            this.buffer.push(int16);
                        }
                    }
                    const CHUNK_SIZE = 1600;
                    while (this.buffer.length >= CHUNK_SIZE) {
                        const chunk = this.buffer.splice(0, CHUNK_SIZE);
                        const int16Array = new Int16Array(chunk);
                        this.port.postMessage(int16Array.buffer, [int16Array.buffer]);
                    }
                    return true;
                }
            }
            registerProcessor('pcm-processor', PCMProcessor);
        `;

        async function setupAudioWorklet() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const blob = new Blob([workletCode], { type: 'application/javascript' });
            const workletUrl = URL.createObjectURL(blob);
            await audioContext.audioWorklet.addModule(workletUrl);
            URL.revokeObjectURL(workletUrl);
        }

        async function setupMicrophone() {
            if (!audioContext) await setupAudioWorklet();
            if (audioContext.state === 'suspended') await audioContext.resume();

            mediaStream = await navigator.mediaDevices.getUserMedia({ 
                audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
            });
            log('Microphone active');
            
            const source = audioContext.createMediaStreamSource(mediaStream);
            workletNode = new AudioWorkletNode(audioContext, 'pcm-processor');
            workletNode.port.onmessage = (event) => {
                if (audioDataChannel?.readyState === 'open') {
                    audioDataChannel.send(event.data);
                }
            };
            source.connect(workletNode);
        }

        function clearAudioBuffer() {
            for (const source of scheduledAudioSources) {
                try { source.stop(); } catch {}
            }
            scheduledAudioSources = [];
            nextStartTime = 0;
        }

        function handleIncomingAudio(data) {
            if (!(data instanceof ArrayBuffer)) return;
            (async () => {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') await audioContext.resume();

                let buffer = data;
                if (buffer.byteLength % 2 !== 0) buffer = buffer.slice(0, buffer.byteLength - 1);
                
                const int16Data = new Int16Array(buffer);
                const float32Data = new Float32Array(int16Data.length);
                for (let i = 0; i < int16Data.length; i++) {
                    float32Data[i] = int16Data[i] / 32768.0;
                }

                const audioBuffer = audioContext.createBuffer(1, float32Data.length, 16000);
                audioBuffer.getChannelData(0).set(float32Data);

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);

                const now = audioContext.currentTime;
                let startTime = nextStartTime < now ? now + 0.05 : nextStartTime;
                source.start(startTime);
                nextStartTime = startTime + audioBuffer.duration;
                
                scheduledAudioSources.push(source);
                source.onended = () => {
                    const idx = scheduledAudioSources.indexOf(source);
                    if (idx > -1) scheduledAudioSources.splice(idx, 1);
                };
            })();
        }

        function handleDataChannelMessage(data) {
            if (data instanceof ArrayBuffer) {
                handleIncomingAudio(data);
            } else if (typeof data === 'string') {
                try {
                    const message = JSON.parse(data);
                    if (message.type === 'clear-audio') clearAudioBuffer();
                    if (message.type === 'call-ended') {
                        log(`Call ended: ${message.reason}`);
                        stopBtn.click();
                    }
                } catch {}
            }
        }

        startBtn.onclick = async () => {
            setStatus('Connecting...', 'idle');
            startBtn.disabled = true;
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            signalingWs = new WebSocket(`${protocol}//${window.location.host}/ws/signaling`);
            
            signalingWs.onopen = async () => {
                log('Connected to server');
                
                // Send provider configuration first (include user name if available)
                signalingWs.send(JSON.stringify({
                    type: 'configure-providers',
                    sttProvider: selectedSTT,
                    ttsProvider: selectedTTS,
                    userName: userName || undefined
                }));
                
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate && signalingWs.readyState === WebSocket.OPEN) {
                        signalingWs.send(JSON.stringify({ type: 'ice-candidate', candidate: event.candidate }));
                    }
                };
                
                peerConnection.onconnectionstatechange = () => {
                    if (peerConnection.connectionState === 'connected') {
                        setStatus('Listening...', 'recording');
                    } else if (['disconnected', 'failed'].includes(peerConnection.connectionState)) {
                        setStatus('Disconnected', 'idle');
                        resetUI();
                    }
                };
                
                audioDataChannel = peerConnection.createDataChannel('audio', { ordered: true });
                audioDataChannel.binaryType = 'arraybuffer';
                
                audioDataChannel.onopen = async () => {
                    log(`Ready! Using ${selectedSTT.toUpperCase()} for speech, ${selectedTTS.toUpperCase()} for voice`);
                    stopBtn.disabled = false;
                    await setupMicrophone();
                };
                
                audioDataChannel.onmessage = (event) => handleDataChannelMessage(event.data);
                
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                signalingWs.send(JSON.stringify({ type: 'offer', sdp: peerConnection.localDescription }));
            };
            
            signalingWs.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                if (message.type === 'answer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp));
                } else if (message.type === 'ice-candidate' && message.candidate) {
                    await peerConnection.addIceCandidate(message.candidate);
                } else if (message.type === 'providers-configured') {
                    log(`Providers configured: STT=${message.providers.sttProvider}, TTS=${message.providers.ttsProvider}`);
                }
            };

            signalingWs.onclose = () => {
                log('Disconnected');
                setStatus('Disconnected', 'idle');
                resetUI();
            };
        };

        stopBtn.onclick = () => {
            log('Ending call...');
            workletNode?.disconnect();
            mediaStream?.getTracks().forEach(track => track.stop());
            audioDataChannel?.close();
            peerConnection?.close();
            signalingWs?.close();
            resetUI();
        };

        function resetUI() {
            startBtn.disabled = false;
            stopBtn.disabled = true;
            setStatus('Ready to help with your career', 'idle');
        }
    </script>
</body>
</html>
